{
    "contents" : "function (formula, ncomp, Y.add, data, subset, na.action, method = pls.options()$mvralg, \n          scale = FALSE, validation = c(\"none\", \"CV\", \"LOO\"), model = TRUE, \n          x = FALSE, y = FALSE, ...) \n{\n  ret.x <- x\n  ret.y <- y\n  mf <- match.call(expand.dots = FALSE)\n  if (!missing(Y.add)) {\n    Y.addname <- as.character(substitute(Y.add))\n    mf$formula <- update(formula, paste(\"~ . +\", Y.addname))\n  }\n  m <- match(c(\"formula\", \"data\", \"subset\", \"na.action\"), names(mf), \n             0)\n  mf <- mf[c(1, m)]\n  mf[[1]] <- as.name(\"model.frame\")\n  mf <- eval(mf, parent.frame())\n  method <- match.arg(method, c(\"kernelpls\", \"widekernelpls\", \n                                \"simpls\", \"oscorespls\", \"cppls\", \"svdpc\", \"model.frame\"))\n  if (method == \"model.frame\") \n    return(mf)\n  mt <- attr(mf, \"terms\")\n  Y <- model.response(mf, \"numeric\")\n  if (is.matrix(Y)) {\n    if (is.null(colnames(Y))) \n      colnames(Y) <- paste(\"Y\", 1:dim(Y)[2], sep = \"\")\n  }\n  else {\n    Y <- as.matrix(Y)\n    colnames(Y) <- deparse(formula[[2]])\n  }\n  if (missing(Y.add)) {\n    Y.add <- NULL\n  }\n  else {\n    Y.add <- mf[, Y.addname]\n    mt <- drop.terms(mt, which(attr(mt, \"term.labels\") == \n                                 Y.addname), keep.response = TRUE)\n  }\n  X <- delete.intercept(model.matrix(mt, mf))\n  nobj <- dim(X)[1]\n  npred <- dim(X)[2]\n  if (length(attr(mt, \"term.labels\")) == 1 && !is.null(colnames(mf[[attr(mt, \n                                                                         \"term.labels\")]]))) \n    colnames(X) <- sub(attr(mt, \"term.labels\"), \"\", colnames(X))\n  if (missing(ncomp)) {\n    ncomp <- min(nobj - 1, npred)\n    ncompWarn <- FALSE\n  }\n  else {\n    if (ncomp < 1 || ncomp > min(nobj - 1, npred)) \n      stop(\"Invalid number of components, ncomp\")\n    ncompWarn <- TRUE\n  }\n  sdscale <- identical(TRUE, scale)\n  if (is.numeric(scale)) \n    if (length(scale) == npred) \n      X <- X/rep(scale, each = nobj)\n  else stop(\"length of 'scale' must equal the number of x variables\")\n  switch(match.arg(validation), CV = {\n    val <- mvrCv(X, Y, ncomp, Y.add = Y.add, method = method, \n                 scale = sdscale, ...)\n  }, LOO = {\n    segments <- as.list(1:nobj)\n    attr(segments, \"type\") <- \"leave-one-out\"\n    val <- mvrCv(X, Y, ncomp, Y.add = Y.add, method = method, \n                 scale = sdscale, segments = segments, ...)\n  }, none = {\n    val <- NULL\n  })\n  if (identical(TRUE, ncomp > val$ncomp)) {\n    ncomp <- val$ncomp\n    if (ncompWarn) \n      warning(\"`ncomp' reduced to \", ncomp, \" due to cross-validation\")\n  }\n  fitFunc <- switch(method, kernelpls = kernelpls.fit, widekernelpls = widekernelpls.fit, \n                    simpls = simpls.fit, oscorespls = oscorespls.fit, cppls = cppls.fit, \n                    svdpc = svdpc.fit)\n  if (sdscale) {\n    scale <- sqrt(colSums((X - rep(colMeans(X), each = nobj))^2)/(nobj - \n                                                                    1))\n    if (any(abs(scale) < .Machine$double.eps^0.5)) \n      warning(\"Scaling with (near) zero standard deviation\")\n    X <- X/rep(scale, each = nobj)\n  }\n  start.time <- proc.time()[3]\n  z <- fitFunc(X, Y, ncomp, Y.add = Y.add, ...)\n  z$fit.time <- proc.time()[3] - start.time\n  class(z) <- \"mvr\"\n  z$na.action <- attr(mf, \"na.action\")\n  z$ncomp <- ncomp\n  z$method <- method\n  if (is.numeric(scale)) \n    z$scale <- scale\n  z$validation <- val\n  z$call <- match.call()\n  z$terms <- mt\n  if (model) \n    z$model <- mf\n  if (ret.x) \n    z$x <- X\n  if (ret.y) \n    z$y <- Y\n  z\n}",
    "created" : 1406915145095.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2424727980",
    "id" : "F8A08141",
    "lastKnownWriteTime" : 1406909552,
    "path" : "~/R/IndiceCiudadesPesos/src/PCRFunction.R",
    "project_path" : "src/PCRFunction.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}